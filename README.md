# map-filter_transformer
  
## Задача:
Язык описания операций над целочисленными массивами задан следующей грамматикой:

digit   ::= “0” | “1" | “2” | “3" | “4” | “5" | “6” | “7" | “8” | “9"

number ::= digit | digit number

operation ::= “+” | “-” | “*” | “>” | “<” | “=” | “&” | “|”

constant-expression ::= “-” number | number

binary-expression ::= “(” expression operation expression “)”

expression ::= “element” | constant-expression | binary-expression

map-call ::= “map{” expression “}”

filter-call ::= “filter{” expression “}”

call ::= map-call | filter-call

call-chain ::= call | call “>%%>” call-chain

Арифметические операции имеют стандартную семантику. 
Операция “&” это логическое “и”, операция “|” --- логическое “или“.
Бинарные выражения с операторам “&”, “|” , “=”, “<”, “>” имеют булевый тип, а с операторами “+”, “-”, “*” --- арифметический.
Операнды арифметических операций должны иметь целочисленный тип, а операнды логических --- булевый.
Вызов функции map заменяет каждый элемент массива на результат вычисления переданного арифметического выражения, в котором вместо element подставляется значение текущего элемента.
Вызов функции filter оставляет в массиве только элементы, для которых переданное выражение истинно.

Последовательность вызовов применяется к массиву по очереди, слева направо.

Необходимо написать преобразователь выражений описываемых правилом call-chain в выражения вида filter-call “%%” map-call, эквивалентные исходному.
Решение принимает на стандартный поток ввода одну строку --- выражение описываемое правилом call-chain и выводить строку с преобразованным выражением.
В случае наличия синтаксической ошибки, программа выдаст SYNTAX ERROR, а если тип выражения не совпадает c ожидаемым TYPE ERROR.

## Сборка
make

make debug **сборка с дампом дерева разбора**

cd tests; ./run_test **запуск тестов**
